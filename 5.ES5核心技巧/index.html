<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>

	<script>
	//VO 全局对象
	//AO 活动对象
		if(false){
			var a = 1;
		}
		alert(a);//undefined


    //函数级作用域
    function test(){
    	if(false){
    		var a = 1;
    	}
    	alert("inner"+a)//innerundefined
    }
    test();  
    alert(a); //undefined，函数里面的变量到外面

    {
    	let b = 2;
    }
    console.log(b);


    //上面的块级作用域的let怎么用es5及以下的语法来实现呢？
    {
    	try{
    		throw 1;
    	}catch(a){
    		console.log(a);
    	}
    }
    console.log(a);

    //使用with也可以形成块级作用域，但是可能会存在一些问题
   	var tency = {a:1};
   	with(tency){
   		var b = 2;  //如果with(tency)的情况下，要对tency里面没有的变量进行赋值，相当于创建了一个新的全局变量，而不是在tency这个作用域里面创建的
   	}
   	console.log(tency.b);   //undefined
   	console.log(b)  //2


   	//******请写出弹出值，并解释为什么
   	+function(){
   		console.log(a);
   		a();
   		var a = function(){
   			console.log(1);
   		}
   		function a(){
   			console.log(2);
   		}
   		console.log(a);
   		a();
   		var c=d=a
   	}();
   	console.log(d);
   	console.log(c);


   	(function(){
   		console.log(a);
   		var a = 1;
   		function a(){
   			console.log(a);
   		}
   	})() //ƒ a(){console.log(a);}


   	(function(){
   		var a = b = 1;
   	})()
   	console.log(b);//1
   	console.log(a);//undefined


   	function test(){
   		var a = 1;
   		return function(){

   		}//a会被回收
   	}
   	function test(){
   		var a = 1;
   		return function(){
   			eval("");
   		}//a 不会被回收	
   	}

   	function test(){
   		var a = 1;
   		return function(){
   			window.eval("");
   		}//a 会被回收，将eval的作用域不是闭包，变成了window	
   	}


   	function test(){
   		this.a = 30,
   		init:function(){
   			a:20;
   			alert(this.a) //20
   		}
   	}





	</script>
</body>
</html>